generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  INCOME
  EXPENSE
}

enum NormalBalance {
  DEBIT
  CREDIT
}

// Optional taxonomy used by Reporting v1 (Trial Balance, P&L, Cashflow later).
// Keep this small initially; we can expand safely later.
enum AccountReportGroup {
  // Balance sheet groupings (working capital + structure)
  CASH_AND_CASH_EQUIVALENTS
  ACCOUNTS_RECEIVABLE
  INVENTORY
  OTHER_CURRENT_ASSET
  FIXED_ASSET

  ACCOUNTS_PAYABLE
  OTHER_CURRENT_LIABILITY
  LONG_TERM_LIABILITY

  EQUITY

  // P&L groupings
  SALES_REVENUE
  OTHER_INCOME
  COGS
  OPERATING_EXPENSE
  OTHER_EXPENSE
  TAX_EXPENSE
}

enum CashflowActivity {
  OPERATING
  INVESTING
  FINANCING
}

enum ItemType {
  GOODS
  SERVICE
}

enum InvoiceStatus {
  DRAFT
  POSTED
  PAID
  PARTIAL
}

enum ExpenseStatus {
  DRAFT
  POSTED
  PARTIAL
  PAID
}

enum BankingAccountKind {
  CASH
  BANK
  E_WALLET
  CREDIT_CARD
}

model Company {
  id              Int              @id @default(autoincrement())
  name            String
  accounts        Account[]
  entries         JournalEntry[]
  events          Event[]
  summaries       DailySummary[]
  accountBalances AccountBalance[]
  customers       Customer[]
  vendors         Vendor[]
  items           Item[]
  invoices        Invoice[]
  payments        Payment[]
  expenses        Expense[]
  expensePayments ExpensePayment[]
  users           User[]
  journalLines    JournalLine[]
  processedEvents ProcessedEvent[]
  invoiceLines    InvoiceLine[]
  bankingAccounts BankingAccount[]

  // Default account settings for this company (multi-tenant safe).
  // Used when posting invoices (Debit AR).
  accountsReceivableAccountId Int?
  accountsReceivableAccount   Account? @relation("Company_AR", fields: [accountsReceivableAccountId], references: [id])

  // Default Accounts Payable account (LIABILITY). Used when posting bills/expenses (Credit AP).
  accountsPayableAccountId Int?
  accountsPayableAccount   Account? @relation("Company_AP", fields: [accountsPayableAccountId], references: [id])

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  idempotentRequests IdempotentRequest[]
  periodCloses       PeriodClose[]
}

model Account {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  code      String // e.g. "1000", "4100"
  name      String // e.g. "Cash on Hand"
  type      AccountType

  // Reporting semantics:
  // - normalBalance: how the account "normally" carries a balance (used for Trial Balance presentation)
  // - reportGroup: optional classification for P&L and Cashflow statement logic
  // - cashflowActivity: optional mapping (Operating/Investing/Financing) for Cashflow statement v1+
  normalBalance   NormalBalance @default(DEBIT)
  reportGroup     AccountReportGroup?
  cashflowActivity CashflowActivity?

  isActive  Boolean     @default(true)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  lines JournalLine[]
  balances AccountBalance[]

  // Books layer relations
  accountsReceivableFor Company[] @relation("Company_AR")
  accountsPayableFor    Company[] @relation("Company_AP")
  incomeItems           Item[]    @relation("Account_IncomeItems")
  expenseItems          Item[]    @relation("Account_ExpenseItems")
  bankPayments          Payment[] @relation("Payment_BankAccount")
  bankExpensePayments   ExpensePayment[] @relation("ExpensePayment_BankAccount")
  bankingAccount        BankingAccount?
  expenses              Expense[] @relation("Expense_ExpenseAccount")

  @@unique([companyId, code]) // one code per company
}

// Daily per-account totals. Used to generate Balance Sheet quickly.
// This is maintained by the worker when journal entries are posted.
model AccountBalance {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  accountId Int
  account   Account @relation(fields: [accountId], references: [id])

  // Store the "day" (00:00 time) here. Balances are per-day increments.
  date DateTime

  debitTotal  Decimal @db.Decimal(18, 2)
  creditTotal Decimal @db.Decimal(18, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, accountId, date])
  @@index([companyId, date])
  @@index([companyId, accountId])
}

model BankingAccount {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  // Each banking account maps 1:1 to a Chart of Accounts Account (ASSET).
  accountId Int     @unique
  account   Account @relation(fields: [accountId], references: [id])

  kind BankingAccountKind

  bankName       String?
  accountNumber  String?
  identifierCode String?
  branch         String?
  description    String? @db.Text
  isPrimary      Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
}

model JournalEntry {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  date        DateTime
  description String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Audit trail: who created this entry (nullable for system/integration jobs)
  createdByUserId Int?
  createdByUser   User? @relation(fields: [createdByUserId], references: [id])

  // Immutable ledger semantics:
  // - Journal entries should never be edited after creation (use reversal/adjustment).
  // - Reversal links back to the original entry.
  postedAt DateTime @default(now())
  reversalOfJournalEntryId Int? @unique
  reversalOfJournalEntry   JournalEntry? @relation("JournalEntry_Reversal", fields: [reversalOfJournalEntryId], references: [id])
  reversalEntry            JournalEntry? @relation("JournalEntry_Reversal")
  reversalReason           String? @db.Text

  lines JournalLine[]

  // Documents that created this journal entry (optional)
  invoice Invoice? @relation("Invoice_JournalEntry")
  payment Payment? @relation("Payment_JournalEntry")
  paymentReversal Payment? @relation("Payment_ReversalJournalEntry")
  expense Expense? @relation("Expense_JournalEntry")
  expensePayment ExpensePayment? @relation("ExpensePayment_JournalEntry")
  expensePaymentReversal ExpensePayment? @relation("ExpensePayment_ReversalJournalEntry")
  periodClose PeriodClose?
}

model JournalLine {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  journalEntryId Int
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id])

  accountId Int
  account   Account @relation(fields: [accountId], references: [id])

  debit  Decimal @db.Decimal(18, 2)
  credit Decimal @db.Decimal(18, 2)

  @@index([companyId])
}

model Event {
  id        Int      @id @default(autoincrement())
  companyId Int?
  company   Company? @relation(fields: [companyId], references: [id])

  eventId       String   @unique // same ID we publish to Pub/Sub
  eventType     String // e.g. "journal.entry.created"
  schemaVersion String // e.g. "v1"
  occurredAt    DateTime @default(now())
  source        String? // e.g. "cashflow-api"

  // --- Event envelope metadata (Step 1) ---
  partitionKey  String? // recommended: String(companyId)
  correlationId String? // recommended: eventId for first event in flow
  causationId   String?
  aggregateType String? // e.g. "JournalEntry"
  aggregateId   String? // e.g. "123"

  // --- Outbox fields (Step 2) ---
  publishedAt          DateTime?
  nextPublishAttemptAt DateTime? @default(now())
  publishAttempts      Int       @default(0)
  lastPublishError     String?   @db.Text
  lockedAt             DateTime?
  lockId               String?

  type      String // e.g. "JournalEntryCreated"
  payload   Json // flexible JSON payload
  createdAt DateTime @default(now())

  @@index([publishedAt, nextPublishAttemptAt])
  @@index([lockedAt])
  @@index([companyId, occurredAt])
}

model ProcessedEvent {
  id          Int      @id @default(autoincrement())
  eventId     String   @unique
  companyId   Int
  company     Company  @relation(fields: [companyId], references: [id])
  processedAt DateTime @default(now())

  @@index([companyId])
}

model DailySummary {
  id           Int      @id @default(autoincrement())
  companyId    Int
  company      Company  @relation(fields: [companyId], references: [id])
  date         DateTime // we will store "day" (00:00 time) here
  totalIncome  Decimal  @db.Decimal(18, 2)
  totalExpense Decimal  @db.Decimal(18, 2)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([companyId, date])
}

// --- Books layer (documents on top of ledger) ---

model Customer {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  name           String
  email          String?
  phone          String?
  currency       String? // e.g. "MMK"
  openingBalance Decimal? @db.Decimal(18, 2)

  invoices Invoice[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
}

model Item {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  name         String
  sku          String?
  type         ItemType
  sellingPrice Decimal  @db.Decimal(18, 2)
  costPrice    Decimal? @db.Decimal(18, 2)

  // Revenue account for sales (should be INCOME)
  incomeAccountId Int
  incomeAccount   Account @relation("Account_IncomeItems", fields: [incomeAccountId], references: [id])

  // Optional expense account for COGS later
  expenseAccountId Int?
  expenseAccount   Account? @relation("Account_ExpenseItems", fields: [expenseAccountId], references: [id])

  isActive     Boolean       @default(true)
  invoiceLines InvoiceLine[]
  expenses     Expense[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
}

model Invoice {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id])

  invoiceNumber String
  status        InvoiceStatus
  invoiceDate   DateTime
  dueDate       DateTime?
  currency      String?
  total         Decimal       @db.Decimal(18, 2) // recomputed and stored when posted
  // Denormalized for performance (avoid summing Payment table on every payment record).
  amountPaid    Decimal       @db.Decimal(18, 2) @default(0)

  journalEntryId Int?          @unique
  journalEntry   JournalEntry? @relation("Invoice_JournalEntry", fields: [journalEntryId], references: [id])

  lines    InvoiceLine[]
  payments Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, invoiceNumber])
  @@index([companyId, invoiceDate])
  @@index([companyId, status])
}

model InvoiceLine {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  itemId Int
  item   Item @relation(fields: [itemId], references: [id])

  description String?
  quantity    Decimal  @db.Decimal(18, 2)
  unitPrice   Decimal  @db.Decimal(18, 2)
  lineTotal   Decimal  @db.Decimal(18, 2)
  taxRate     Decimal? @db.Decimal(5, 2)

  @@index([companyId])
}

model Payment {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  paymentDate DateTime
  amount      Decimal  @db.Decimal(18, 2)

  bankAccountId Int
  bankAccount   Account @relation("Payment_BankAccount", fields: [bankAccountId], references: [id])

  journalEntryId Int?          @unique
  journalEntry   JournalEntry? @relation("Payment_JournalEntry", fields: [journalEntryId], references: [id])

  // Reversal (immutable audit): never delete/edit payment; record reversal metadata.
  reversedAt              DateTime?
  reversalReason          String?   @db.Text
  reversalJournalEntryId  Int?      @unique
  reversalJournalEntry    JournalEntry? @relation("Payment_ReversalJournalEntry", fields: [reversalJournalEntryId], references: [id])
  reversedByUserId        Int?
  reversedByUser          User? @relation("User_ReversedPayments", fields: [reversedByUserId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId, paymentDate])
  @@index([invoiceId])
}

model Vendor {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  name  String
  email String?
  phone String?

  expenses Expense[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
}

model Expense {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  vendorId Int?
  vendor   Vendor? @relation(fields: [vendorId], references: [id])

  expenseNumber String
  status        ExpenseStatus
  expenseDate   DateTime
  dueDate       DateTime?
  description   String

  amount     Decimal @db.Decimal(18, 2)
  amountPaid Decimal @db.Decimal(18, 2) @default(0)
  currency String?

  // Optional item reference for COGS tracking
  itemId Int?
  item   Item? @relation(fields: [itemId], references: [id])

  // Expense account (Debit) used when posting (must be EXPENSE).
  expenseAccountId Int?
  expenseAccount   Account? @relation("Expense_ExpenseAccount", fields: [expenseAccountId], references: [id])

  // When posted, links to journal entry (Dr expense / Cr AP)
  journalEntryId Int?          @unique
  journalEntry   JournalEntry? @relation("Expense_JournalEntry", fields: [journalEntryId], references: [id])

  payments ExpensePayment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, expenseNumber])
  @@index([companyId, expenseDate])
  @@index([companyId, status])
}

model ExpensePayment {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  expenseId Int
  expense   Expense @relation(fields: [expenseId], references: [id])

  paymentDate DateTime
  amount      Decimal @db.Decimal(18, 2)

  bankAccountId Int
  bankAccount   Account @relation("ExpensePayment_BankAccount", fields: [bankAccountId], references: [id])

  journalEntryId Int?          @unique
  journalEntry   JournalEntry? @relation("ExpensePayment_JournalEntry", fields: [journalEntryId], references: [id])

  // Reversal (immutable audit): never delete/edit payment; record reversal metadata.
  reversedAt             DateTime?
  reversalReason         String? @db.Text
  reversalJournalEntryId Int?    @unique
  reversalJournalEntry   JournalEntry? @relation("ExpensePayment_ReversalJournalEntry", fields: [reversalJournalEntryId], references: [id])
  reversedByUserId       Int?
  reversedByUser         User? @relation("User_ReversedExpensePayments", fields: [reversedByUserId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId, paymentDate])
  @@index([expenseId])
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String // hashed
  name      String?
  companyId Int
  company   Company  @relation(fields: [companyId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  journalEntriesCreated JournalEntry[]
  reversedPayments      Payment[] @relation("User_ReversedPayments")
  reversedExpensePayments ExpensePayment[] @relation("User_ReversedExpensePayments")
  periodClosesCreated PeriodClose[] @relation("User_PeriodClosesCreated")

  @@index([companyId])
}

// Period close (month-end/year-end) to move INCOME/EXPENSE into Retained Earnings.
// Prevents accidental double-close for the same period.
model PeriodClose {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  fromDate DateTime
  toDate   DateTime

  journalEntryId Int @unique
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id])

  createdByUserId Int?
  createdByUser   User? @relation("User_PeriodClosesCreated", fields: [createdByUserId], references: [id])

  createdAt DateTime @default(now())

  @@unique([companyId, fromDate, toDate])
  @@index([companyId, toDate])
}

// Command-level idempotency for HTTP writes (safe under retries).
// Unique per (companyId, key). Store the previously returned response so retries can return the same result.
model IdempotentRequest {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  key      String
  response Json

  createdAt DateTime @default(now())

  @@unique([companyId, key])
  @@index([companyId, createdAt])
}
